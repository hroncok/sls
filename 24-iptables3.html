<meta http-equiv="content-type" content="text/html;charset=utf-8" />


<h1>Správa linuxového serveru: Linuxový firewall, základy iptables III</h1>

<p>V tomto dílu proberu použití vlastních řetězců ke zpřehlednění firewallu,    možnosti logování paketů a filtrování předávaných (routovaných) paketů.</p>

<h4>Vlastní řetězce</h4>
<p>Netfilter umožňuje definovat vlastní řetězce, a tím pravidla paketového filtru logicky členit a zjednodušit. Je to podobné jako práce s funkcemi v programovacím jazyce. Jak už víte, Netfilter zná tři základní řetězce: <code>INPUT</code>, <code>OUTPUT</code> a <code>FORWARD</code>. Tyto řetězce nelze smazat, pouze vyčistit. Je možné vytvořit nový řetězec a v existujících řetězcích se na něj pak odkázat, tedy poslat paket, který vyhoví danému pravidlu, do daného řetězce. Uživatelem definované řetězce nemají politiku, takže pokud paket uživatelským řetězcem projde, aniž by byl zachycen nějakým pravidlem, vrací se zpět do řetězce, odkud byl do uživatelsky definovaného řetězce odeslán.</p>
<p>Asi nejlepší bude demonstrovat tuto funkci na příkladu. Za tímto účelem rozšířím firewall, který jsem vám předvedl v minulém díle:</p>
<pre>1.  iptables -F
2.  iptables -X
3.  iptables -P INPUT DROP
4.  iptables -P OUTPUT ACCEPT
5.  iptables -P FORWARD DROP

6.  iptables -N ssh
7.  iptables -A ssh -s 10.0.0.0/8 -j ACCEPT
8.  iptables -A ssh -s 43.21.12.34 -j DROP
9.  iptables -A ssh -m limit --limit 5/sec --limit-burst 100 -j ACCEPT
10. iptables -A ssh -j DROP

11. iptables -A INPUT -i lo -j ACCEPT
12. iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
13. iptables -A INPUT -m state --state INVALID -j DROP
14. iptables -A INPUT -p tcp --dport 22 -m state --state NEW -j ssh
15. iptables -A INPUT -p tcp --dport 80 -m state --state NEW -j ACCEPT
16. iptables -A INPUT -p icmp -j ACCEPT
17. iptables -A INPUT -j DROP
</pre>
<p>Příkaz na prvním řádku odstraní všechna pravidla ze všech řetězců, druhý příkaz odstraní všechny prázdné uživatelem definované řetězce. Následuje vytvoření nového řetězce s názvem <code>ssh</code>, kde je naznačen whitelist a blacklist (řádky 7 a 8), a poté následuje omezení počtu spojení na SSH (řádek 9). Poslední pravidlo v řetězci (řádek 10) zahazuje všechny pakety, které neodpoví některému z pravidel v řetězci.</p>
<p>Na řetězec <code>ssh</code> je odkázáno na řádku 14, kde je uživatelsky    definovaný řetězec předán parametru <code>-j</code>, který určuje, co se má    s paketem vyhovujícím danému pravidlu provést. Příchozí pakety tedy v    případě takto definovaného firewallu dorazí nejprve do řetězce    <code>INPUT</code>, tedy na řádek č. 11, a teprve pakety, které vyhoví    pravidlu na řádku č. 14, budou poslány do řetězce <code>ssh</code>.</p>
<p>Na další příklad užití vlastních řetězců (a o něco lepší metodu zabezpečení SSH na úrovni firewallu) se můžete podívat ve <a href="http://www.linuxexpres.cz/praxe/debian-server-prakticke-rady-pro-zabezpeceni-ssh-4">čtvrtém dílu</a> miniseriálu o zabezpečení SSH.</p>
<p>Pokud potřebujete paket z řetězu propustit, aniž by byl přijat, odmítnut nebo zahozen, tedy aby se vrátil zpět do původního řetězu, odkud byl do daného uživatelem definovaného řetězu vyslán, použijte <code>RETURN</code> jako parametr pro <code>-j</code>, takto:</p>
<pre>    [...]
 
1.  iptables -N whitelist
2.  iptables -A whitelist -s 10.0.0.0/8 -j RETURN
3.  iptables -A whitelist -j DROP

    [...]
 
4.  iptables -A INPUT [...] -j whitelist

    [...]
</pre>
<p>V tomto případě bude paket vyhovující čtvrtému pravidlu poslán do řetězce    <code>whitelist</code>, kde projde pravidlem č. 2, přičemž pokud mu vyhoví,    poputuje zpět do řetězce <code>INPUT</code> za pravidlo č. 4, pokud mu    nevyhoví, pak dorazí k pravidlu č. 3 a bude zahozen.</p>
<h3>Logování paketů</h3>
<p>Někdy může být velice žádoucí, abyste určitý specifický síťový provoz monitorovali trošku blíže, tedy abyste nechali jisté pakety logovat. Pokud se ještě chvilku budu držet příkladů na vlastní řetězce, mohl by příklad na logování paketů vypadat třeba takto:</p>
<pre>    [...]

1.  iptables -N 
2.  iptables -A strange -s 10.0.0.0/8 -j LOG --log-prefix "iptables-strange-local: "
3.  iptables -A strange -s 12.23.34.45 -j LOG --log-prefix "iptables-strange-offender: "
4.  iptables -A strange -j DROP

    [...]

5   iptables -A INPUT -m state --state INVALID -j strange

    [...]
</pre>
<p>V tomto příkladu jsou všechny pakety ve stavu <code>INVALID</code> poslány do uživatelsky definovaného řetězce <code>strange</code>, ve kterém dochází k výběru jedné sítě a jedné IP adresy, u nichž se provádí logování. Všechno ostatní se zahazuje.</p>
<p>Samotné logování je průchozí operace, tzn. pokud paket pravidlu s cílem <code>LOG</code> vyhoví, je zalogován, ale pokračuje dál. Proto je zde na řádku č. 4 definováno pravidlo, které všechny pakety v tomto řetězci zahodí. Samotné logování má nepovinnou volbu <code>--log-prefix</code>, která umožňuje specifikovat, čím bude hlášení na řádce se záznamem v logu začínat. Výsledek pak v logu může vypadat třeba takto:</p>
<pre>Jul 25 03:49:51 debian kernel: [5466089.604926] iptables-strange-local: IN=eth0 OUT=eth1 SRC=10.0.1.15 DST=1.2.3.4 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=22177 DF PROTO=TCP SPT=45320 DPT=22 WINDOW=5840 RES=0x00 SYN URGP=0 UID=0 GID=0
</pre>
<p>Množství informací, které jsou o daných paketech získávány, můžete ovlivnit volbou <code>--log-level</code>.</p>
<h4>Malý příklad na procvičení</h4>
<p>Podívejte se na následující příklad a zauvažujte, co se stane s paketem, který je ve stavu <code>INVALID</code> a má zdrojovou IP adresu <code>10.0.1.12</code>?</p>
<pre>1.  iptables -P INPUT ACCEPT

2.  iptables -N 
3.  iptables -A strange -s 10.0.0.0/8 -j LOG --log-prefix "iptables-strange-local "
4.  iptables -A strange -s 12.23.34.45 -j LOG --log-prefix "iptables-strange-offender "

5.  iptables -A INPUT -i lo -j ACCEPT
6.  iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
7.  iptables -A INPUT -m state --state INVALID -j strange
</pre>
<p>Paket dorazí do řetězce <code>INPUT</code>, kde je zachycen pravidlem na    řádku č. 7 a odeslán do řetězce <code>strange</code>. Zde vyhoví pravidlu na    řádku č. 3 a je zalogován. Jelikož logování je průchozí operace, pokračuje    paket po zalogování dál, avšak v řetězci <code>strange</code> již nejsou    žádná další pravidla, tudíž bude příslušný paket vrácen zpět do řetězce    <code>INPUT</code>. Zde již také nejsou žádná pravidla, tudíž bude s paketem    naloženo dle výchozí politiky pro řetězec <code>INPUT</code>, a paket bude    propuštěn, což je samozřejmě v případě <code>INVALID</code> paketů patrně    nežádoucí.</p>
<h4>Řetězec FORWARD a routing v GNU/Linuxu</h4>
<p>GNU/Linux může fungovat jako router, tedy předávat pakety z jednoho rozhraní na jiné, z jedné sítě do druhé. Pakety, které nejsou určeny pro daný počítač, nýbrž jím jen prochází, putují v rámci paketového filtru řetězcem <code>FORWARD</code>. To je důvodem, proč v dřívějších příkladech byla politika pro řetězec <code>FORWARD</code> nastavena na <code>DROP</code>.</p>
<p>K samotnému zprovoznění routingu je však zapotřebí routing povolit v konfiguraci jádra, tedy v <code>sysctl.conf</code>:</p>
<pre>net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1
</pre>
<p>Všimněte si, že je zde opět oddělen protokol IPv4 a IPv6, tzn. předávání paketů se nastavuje individuálně pro každý z protokolů. Změna tohoto konfiguračního souboru se projeví až po restartu, i když je samozřejmě možné příslušnou změnu provést ručně a okamžitě, prostřednictvím nástroje <code>sysctl</code>:</p>
<pre>sysctl -w net.ipv4.ip_forward=1
sysctl -w net.ipv6.conf.all.forwarding=1
</pre>
<p>Samotné filtrování předávaných paketů pak může vypadat třeba takto:</p>
<pre>    [...]
 
1.  iptables -P FORWARD DROP
2.  iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
3.  iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT 
4.  iptables -A FORWARD -s 10.0.0.0/24 -d 10.0.1.0/24 -j ACCEPT
5.  iptables -A FORWARD -s 10.0.1.0/24 -d 10.0.0.0/24 -j ACCEPT

    [...]
</pre>
<p>Zde je na prvním řádku nastavena výchozí politika řetězce <code>FORWARD</code>, na druhém řádku je povolen průchod paketů, které náleží již vytvořeným spojením, nebo se jich týkají, na třetím řádku je pak povolen veškerý síťový provoz směřující z rozhraní <code>eth0</code> na rozhraní <code>eth1</code>, a konečně na posledních dvou řádcích je povolen provoz v obou směrech mezi sítěmi <code>10.0.0.0/24</code> a <code>10.0.1.0/24</code>.</p>
<h4>Alternativy k iptables</h4>
<p>Nastavovat firewall je komplikovaná záležitost, což je patrně z dosavadních dílů o základech <code>iptables</code> více než jasné. Proto existuje řada projektů, které si kladou za cíl stavbu firewallu zjednodušit. Existují dokonce i jisté ekvivalenty "osobních" firewallů, které se snaží být uživatelsky přívětivé a zaměřují se na běžné uživatele. Tím je třeba nástroj <a href="http://www.fs-security.com/">Firestarter</a>.</p>
<p>Jiné typy nástrojů se pokouší usnadnit vytváření pravidel, ať již snahou o usnadnění návrhu komplikovaného firewallu (<a href="http://www.fwbuilder.org/">fwbuilder</a>), nebo značným zjednodušením syntaxe (<a href="https://launchpad.net/ufw">ufw</a>, <a href="http://firehol.sourceforge.net/">FireHOL</a>, atd.).</p>
<p>Na závěr jsem si nechal projekt Shorewall, což je de facto nadstavba nad    <code>iptables</code>, která z několika přehledných konfiguračních souborů    vygeneruje příslušná pravidla pro nástroj <code>iptables</code> a nastaví    linuxový paketový filtr.  Pokud se chcete o Shorewallu dozvědět více, můžete    se podívat na článek <a href="http://www.linuxexpres.cz/software/shorewall-2-rychla-obrana-na-stanici">Shorewall 2 - rychlá obrana na stanici</a> a dvoudílný miniseriál o Shorewallu (<a href="http://www.linuxexpres.cz/praxe/shorewall-1-dil-1">1. díl</a>, <a href="http://www.linuxexpres.cz/praxe/shorewall-2-dil">2. díl</a>).</p>

<pre id="links">http://linux.die.net/man/8/iptables man iptables
http://linux.die.net/man/8/ip6tables man ip6tables
http://fedorasolved.org/Members/kanarip/iptables-howto Iptables Howto
http://www.faqs.org/docs/iptables/statemachine.html The state machine (iptables tutorial)
http://www.linuxhomenetworking.com/wiki/index.php/Quick_HOWTO_:_Ch14_:_Linux_Firewalls_Using_iptables Linux firewalls using iptables</pre>
